#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>
#include "playState.hpp"
#include "jsonLoader.hpp"
#include "structs.hpp"
#include "textures.hpp"
#include "projectile.hpp"
#include "enemy.hpp"
#include "values.hpp"

const std::string PlayState::s_playID = "PLAY";

void PlayState::add( Sprite* sprite ) {
  sprite -> setSpriteID( nextSpriteID_ );
  nextSpriteID_++;
  
  sprites_.push_back( sprite );
  spritesSize_ = sprites_.size();
  
}

int getSpriteID( int& newSpriteID, int& nextSpriteID ) {
  newSpriteID = nextSpriteID;
  nextSpriteID++;
  return newSpriteID;
}

bool PlayState::onEnter() {
  
  // get vector of ObjectData
  JsonLoader jsonLoader;
  jsonLoader.loadDataMain( commonObjectsData_ );
  
  for( unsigned int i = 0; i < commonObjectsData_.size(); i++ ) {
    if( commonObjectsData_[i] -> objectType == "Hero" ) {
      hero_ = new Hero( std::move( commonObjectsData_[i] ) );
      PlayState::add( hero_ );
    } else if( commonObjectsData_[i] -> objectType == "Target" ) {
      target_ = new Target( std::move( commonObjectsData_[i] ) );
      PlayState::add( target_ );
    } else if( commonObjectsData_[i] -> objectType == "PBomb" ) {
      pBombObjectData_ = ( *commonObjectsData_[i] );
    }
  }
  
  PlayState::loadLevelFromFile( TheValues::Instance() -> getNextLevel() );
  
  levelStart_ = SDL_GetTicks();
  
  return true;
}

bool PlayState::loadLevelFromFile( int currentLevel ) {

  JsonLoader jsonLoader;
  jsonLoader.loadLevel( currentLevel, levelObjectsData_, backgroundFilename_, pointsNeeded_ );
  
  TheTextures::Instance() -> load( backgroundFilename_, "background" );
  
  pointsNeeded_ = TheValues::Instance() -> getPointsNeeded();
  
  //TheValues::Instance() -> updatePointsNeeded( pointsNeeded_ );
  hud_ = new Hud( pointsNeeded_ );
  
  return true;
}

void PlayState::spawnProjectile( int projectileType, Sprite* originSprite ) {
  
  ProjectileData projectileData;
  
  projectileData.type = projectileType;
  
  if( projectileType < 3 ) { // generated by the hero
    pBombObjectData_.x = hero_ -> getPosition().getSpriteCenter().getX();
    pBombObjectData_.y = hero_ -> getPosition().getSpriteCenter().getY();
    
    projectileData.srcX = pBombObjectData_.x;
    projectileData.srcY = pBombObjectData_.y;
    projectileData.dstX = target_ -> getPosition().getCoordinates().getX();
    projectileData.dstY = target_ -> getPosition().getCoordinates().getY();
  } else { // generated by enemy
    pBombObjectData_.x = originSprite -> getPosition().getCoordinates().getX();
    pBombObjectData_.y = originSprite -> getPosition().getCoordinates().getY();
  
    projectileData.srcX = originSprite -> getPosition().getCoordinates().getX();
    projectileData.srcY = originSprite -> getPosition().getCoordinates().getY();
    
    projectileData.dstX = hero_ -> getPosition().getSpriteCenter().getX();
    projectileData.dstY = hero_ -> getPosition().getSpriteCenter().getY();
    
    projectileData.speedFactor = 1.0f;
    
  }
  
  std::unique_ptr<ObjectData> projectileObjectData ( new ObjectData( pBombObjectData_ ) );
  
  if( projectileType == PBULLET ) {
    projectileData.speedFactor = 7.0f;
    projectileData.destroyAtDest = true;
    projectileObjectData -> objectType = "PBullet";
  } else if( projectileType == PBOMB ) {
    projectileData.speedFactor = 1.8f;
    
  }
  
  Projectile* newProjectile = new Projectile( std::move( projectileObjectData ), projectileData );
  PlayState::add( newProjectile );
}

int PlayState::getSpriteVectorPosition( int spriteID ) {
  for( int i = 0; i < spritesSize_; i++ ) {
    if( sprites_[i] -> getSpriteID() == spriteID ) {
      return i;
    }
  }
  return -1;
}

void PlayState::levelBeaten( float dt, Uint32 msFrameDiff ) {

  // delete all the enemies and projectiles
  for( unsigned i = spritesSize_; i-- > 0; ) {
    std::string objectType = sprites_[i] -> getObjectType();
    if( objectType != "Hero" && objectType != "Target" && objectType != "Scenary" ) {
      printf( "deleting %d\n", i );
      sprites_[i] -> clean();
      delete sprites_[i];
      sprites_.erase( sprites_.begin() + i );
    }
  }
  spritesSize_ = sprites_.size();
  
  for( int i = 0; i < spritesSize_; i++ ) {
    sprites_[i] -> update( dt, msFrameDiff );
  }
}

void PlayState::gameLogic( float dt, Uint32 msFrameDiff ) {
  for( int i = 0; i < spritesSize_; i++ ) {
    sprites_[i] -> update( dt, msFrameDiff );
    
    projectileType_ = sprites_[i] -> spawnProjectile();
    if( projectileType_ > 0 ) {
      PlayState::spawnProjectile( projectileType_, sprites_[i]  );
      sprites_[i] -> setSpawnProjectile( false );
    }
  }
  
  //delete dead stuff
  for( unsigned i = spritesSize_; i-- > 0; ) {
    if( sprites_[i] -> needsDeleting() ) {
      //printf( "deleting %d\n", i );
      sprites_[i] -> clean();
      delete sprites_[i];
      sprites_.erase( sprites_.begin() + i );
    }
  }
  spritesSize_ = sprites_.size();
  
  // caculate collisions / damage
  collisions_ = myCollision_.getCollisions( sprites_, spritesSize_ );
  
  spriteHit_ = nullptr; // for player firing so we only hit one enemy
  
  if( !collisions_.empty() ) {
    for( unsigned int c = 0; c < collisions_.size(); c++ ) {
      
      //int id1 = collisions_[c].first  -> getSpriteID();
      //int id2 = collisions_[c].second -> getSpriteID();
      
      spriteOnePos_ = PlayState::getSpriteVectorPosition( collisions_[c].first  -> getSpriteID() );
      spriteTwoPos_ = PlayState::getSpriteVectorPosition( collisions_[c].second  -> getSpriteID() );
      
      //printf( "%d collided with %d\n", spriteOnePos_, spriteTwoPos_ );
      
      if( spriteOnePos_ == 1 && spriteTwoPos_ > 1 && sprites_[0] -> getSpriteState() != DYING ) { // target hitting enemy / scenary
        if( target_ -> getSpriteState() == FIRING ) {
          if( spriteHit_ ) {
            if( spriteHit_ -> getBottomY() < sprites_[spriteTwoPos_] -> getBottomY() ) {
              spriteHit_ = sprites_[spriteTwoPos_];
            }
          } else {
            spriteHit_ = sprites_[spriteTwoPos_];
          }
        }
      }
      if( spriteOnePos_ == 0 && spriteTwoPos_ > 1 ) { // enemy hitting player
        if( sprites_[0] -> getSpriteState() != DYING && sprites_[ spriteTwoPos_ ] -> isHostileToHero() && !hero_ -> isInv() ) {
          hero_ -> reduceHp( 1 );
	      }
      }
    }
  }
  
  if( spriteHit_ ) {
    spriteHit_ -> reduceHp( 10 );
  }
  
  currentTime_ = SDL_GetTicks();
  
  // spawn enemies
  if( !levelObjectsData_.empty() ) {
    for( unsigned i = levelObjectsData_.size(); i-- > 0; ) {
      if( currentTime_ > ( levelStart_ + ( levelObjectsData_[i] -> spawnTime * 1000 ) ) ) {
        Enemy* newEnemy = new Enemy( std::move( levelObjectsData_[i] ) );
        PlayState::add( newEnemy );
        levelObjectsData_.erase( levelObjectsData_.begin() + i );
      }
    }
  }
}

void PlayState::update( float dt, Uint32 msFrameDiff ) {

  // check whether level has been beaten
  if( TheValues::Instance() -> getPoints() >= pointsNeeded_ ) {
    PlayState::levelBeaten( dt, msFrameDiff );
  } else {
    PlayState::gameLogic( dt, msFrameDiff );
  }
  
  hud_ -> update( dt, msFrameDiff );
}

template<typename A, typename B> std::pair<B,A> flip_pair( const std::pair<A,B> &p) {
  return std::pair<B,A>( p.second, p.first );
}

template<typename A, typename B> std::multimap<B,A> flip_map(const std::map<A,B> &src) {
  std::multimap<B,A> dst;
  std::transform(src.begin(), src.end(), std::inserter(dst, dst.begin()), flip_pair<A,B>);
  return dst;
}

void PlayState::render() {
  
  TheTextures::Instance() -> draw( "background", 0, 0, 1280, 720 );
  
  //  cpp.sh/7pky
  std::map<int, int> src; // map of draw indexes so we know which order to draw
  
  for( int i = 0; i < spritesSize_; i++ ) { // populate map
    src[i] = sprites_[i] -> getDrawIndex();
  }
  
  src[0] = 1001;
  src[1] = 1000;
  
  dst = flip_map( src ); // order by value
  
  for ( std::multimap<int, int>::iterator it=dst.begin(); it!=dst.end(); ++it ) {
    sprites_[ (*it).second ] -> render();
  }
  
  src.clear();
  dst.clear();
  
  hud_ -> render();
}

bool PlayState::onExit() {

  delete hud_;
  delete hero_;
  delete target_;
  
  return true;
}
